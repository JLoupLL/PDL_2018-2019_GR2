! while;do while;for i = first to last;foreach;
Ada[1];while condition loop <dl><dd>statements</dd></dl> end loop;loop <dl><dd>statements</dd><dd>'''exit when not''' condition</dd></dl> end loop;for index in «reverse» [first .. last | discrete_type] loop <dl><dd>statements</dd></dl> end loop;for item of «reverse» iterator loop <dl><dd>statements</dd></dl> end loop (for [all | some] [in | of] [first .. last | discrete_type | iterator] => predicate){{ref|Ada_quantifiers|[b]}};
ALGOL 68;«for index» «from first» «by increment» «to last» «while condition» do statements od;for key «to upb list» do «typename val=list[key];» statements od;
«while condition»     do statements od;«while statements; condition»     do statements od;«for index» «from first» «by increment» «to last» do statements od;
APL;:While condition<dl><dd>statements</dd></dl> :EndWhile;:Repeat <dl><dd>statements</dd></dl>:Until condition;:For var«s» :In list<dl><dd>statements</dd></dl> :EndFor;:For var«s» :InEach list<dl><dd>statements</dd></dl> :EndFor;
C (C99);while (condition) { instructions };do { instructions } while (condition);for («type» i = first; i <= last; ++i) { instructions };{{n/a}};
Objective-C;for (type item in set) { instructions };
C++ (STL);«std::»for_each(start, end, function) (C++11) for (type item : set) { instructions };
C#;foreach (type item in set) { instructions };
Java;for (type item : set) { instructions };
JavaScript;for (var i = first; i <= last; i++) { instructions };for (var index in set) { instructions } or for each (var item in set) { instructions } (JS 1.6+, deprecated[10]) or for (var item of set) { instructions } (EcmaScript 6 proposal, supported in Firefox[11]);
PHP;foreach (range(first, last) as $i) { instructions } or for ($i = first; $i <= last; $i++) { instructions };foreach (set as item) { instructions } or foreach (set as key => item) { instructions };
Windows PowerShell;for ($i = first; $i -le last; $i++) { instructions };foreach (item in set) { instructions using item };
D;foreach (i; first ... last) { instructions };foreach («type» item; set) { instructions };
Go;for condition { instructions };;for i := first; i <= last; i++ { instructions };for key, item := range set { instructions };
Swift;while condition { instructions };repeat { instructions } while condition (2.x) do { instructions } while condition (1.x);for i = first ... last { instructions } or for i = first ..< last+1 { instructions } or for var i = first; i <= last; i++ { instructions };for item in set { instructions };
Perl;while (condition) { instructions } or until (notcondition) { instructions };do { instructions } while (condition) or do { instructions } until (notcondition);for«each» «$i» (first .. last) { instructions } or for ($i = first; $i <= last; $i++) { instructions };for«each» «$item» (set) { instructions };
Perl 6;while condition { instructions } or until notcondition { instructions };repeat { instructions } while condition or repeat { instructions } until notcondition;for first..last -> $i { instructions } or loop ($i = first; $i <=last; $i++) { instructions };for set« -> $item» { instructions };
Ruby;while condition <dl><dd>instructions</dd></dl>end or until notcondition <dl><dd>instructions</dd></dl> end;begin <dl><dd>instructions</dd></dl> end while condition or begin <dl><dd>instructions</dd></dl> end until notcondition;for i in first..last <dl><dd>instructions</dd></dl> end or for i in first...last+1 <dl><dd>instructions</dd></dl> end or first.{{not a typo|upto}}(last) { |i| instructions };for item in set <dl><dd>instructions</dd></dl> end or set.each { |item| instructions };
Bash shell;while condition ;do<dl><dd>instructions</dd></dl>done or until notcondition ;do<dl><dd>instructions</dd></dl> done;{{n/a}};for ((i = first; i <= last; ++i)) ; do <dl><dd>instructions</dd></dl> done;for item in set ;do<dl><dd>instructions</dd></dl> done;
Scala;while (condition) { instructions };do { instructions } while (condition);for (i <- first to last «by 1») { instructions } or first to last «by 1» foreach (i => { instructions });for (item <- set) { instructions } or set foreach (item => { instructions });
Smalltalk;conditionBlock whileTrue: <dl><dd>loopBlock</dd></dl>;loopBlock doWhile: <dl><dd>conditionBlock</dd></dl>;first to: last do: <dl><dd>loopBlock</dd></dl>;collection do: <dl><dd>loopBlock</dd></dl>;
Common Lisp;(loop<dl><dd>while '''condition'''</dd><dd>do</dd><dd>'''instructions''')'''</dd></dl> or (do () (notcondition)<dl><dd>'''instructions''')'''</dd></dl>;(loop<dl><dd>do</dd><dd>'''instructions'''</dd><dd>while '''condition''')'''</dd></dl>;(loop<dl><dd>for i from '''first''' to '''last''' «by 1»</dd><dd>do</dd><dd>'''instructions''')'''</dd></dl> or (dotimes (i N)<dl><dd>instructions''')'''</dd></dl> or (do ((i first (1+ i))) ((>= i last))<dl><dd>'''instructions''')'''</dd></dl>;(loop<dl><dd>for '''item''' in '''list'''</dd><dd>do</dd><dd>'''instructions''')'''</dd></dl> or (loop<dl><dd>for '''item''' across '''vector'''</dd><dd>do</dd><dd>'''instructions''')'''</dd></dl> or (dolist (item list)<dl><dd>'''instructions''')'''</dd></dl> or (mapc function list) or (map 'type function sequence);
Scheme;(do () (notcondition) instructions) or (let loop () (if condition (begin instructions (loop))));(let loop () (instructions (if condition (loop))));(do ((i first (+ i 1))) ((>= i last)) instructions) or (let loop ((i first)) (if (< i last) (begin instructions (loop (+ i 1)))));(for-each (lambda (item) instructions) list);
ISLISP;(while condition instructions);(tagbody loop instructions (if condition (go loop));(for ((i first (+ i 1))) ((>= i last)) instructions);(mapc (lambda (item) instructions) list);
Pascal;while condition do begin <dl><dd>instructions</dd></dl> end;repeat <dl><dd>instructions</dd></dl> until notcondition;;for i := first «step 1» to last do begin <dl><dd>instructions</dd></dl> end;{{ref|step|[a]}};for item in set do ...;
Visual Basic;Do While condition <dl><dd>instructions</dd></dl>Loop or Do Until notcondition <dl><dd>instructions</dd></dl>Loop;Do <dl><dd>instructions</dd></dl> Loop While condition or Do <dl><dd>instructions</dd></dl> Loop Until notcondition;For i = first To last «Step 1» <dl><dd>instructions</dd></dl> Next i;For Each item In set <dl><dd>instructions</dd></dl> Next item;
Visual Basic .NET;For i «As type» = first To last «Step 1» <dl><dd>instructions</dd></dl>Next i{{ref|step|[a]}};For Each item As type In set <dl><dd>instructions</dd></dl> Next item;
Xojo;While condition <dl><dd>instructions</dd></dl>Wend;Do Until notcondition <dl><dd>instructions</dd></dl>Loop or Do <dl><dd>instructions</dd></dl> Loop Until notcondition;
Python;while condition : {{keypress|Tab}} instructions «else: {{keypress|Tab}} instructions»;{{n/a}};for i in range(first, last+1): {{keypress|Tab}} instructions «else: {{keypress|Tab}} instructions»(Python 3.x) for i in xrange(first, last+1): {{keypress|Tab}} instructions «else: {{keypress|Tab}}instructions»(Python 2.x);for item in set: {{keypress|Tab}} instructions «else: {{keypress|Tab}} instructions»;
S-Lang;while (condition) { instructions } «then optional-block»;do { instructions } while (condition) «then optional-block»;for (i = first; i <= last; i++) { instructions } «then optional-block»;foreach item(set) «using (what)» { instructions } «then optional-block»;
Fortran;DO WHILE (condition) <dl><dd> '''instructions'''</dd></dl> ENDDO;DO <dl><dd> '''instructions''' <br/> IF ('''condition''') EXIT </dd></dl> ENDDO;DO I = first,last <dl><dd> '''instructions''' </dd></dl> ENDDO;{{n/a}};
Forth;BEGIN « instructions » condition WHILE instructions REPEAT;BEGIN instructions condition UNTIL;limit start DO instructions LOOP;{{n/a}};
OCaml;while condition do instructions done;{{n/a}};for i = first to last do instructions done;Array.iter (fun item -> instructions) array List.iter (fun item -> instructions) list;
F#;while condition do {{keypress|Tab}} instructions;{{n/a}};for i = first to last do {{keypress|Tab}} instructions;for item in set do {{keypress|Tab}} instructions or Seq.iter (fun item -> instructions) set;
Standard ML;while condition do ( instructions );colspan=2 {{n/a}};Array.app (fn item => instructions) array app (fn item => instructions) list;
Haskell (GHC);colspan=2 {{n/a}};Control.Monad.forM_ [first..last] (\i -> do instructions);Control.Monad.forM_ list (\item -> do instructions);
Eiffel;from <dl><dd>setup</dd></dl> until <dl><dd>condition</dd></dl> loop <dl><dd>instructions</dd></dl> end;
CoffeeScript;while condition <dl><dd>expression</dd></dl>;rowspan=6 {{n/a}};for i in [first..last] <dl><dd>expression</dd></dl>;for item in set <dl><dd>expression</dd></dl>;
expression while condition;
while condition then expression;
until condition <dl><dd>expression</dd></dl>;
expression until condition;for i in [first..last] then expression;for item in set then expression;
until condition then expression;expression for i in [first..last];expression for item in set;
COBOL;PERFORM procedure-1 «THROUGH procedure-2» ««WITH» TEST BEFORE» UNTIL condition{{ref|COBOL THRU|[c]}};PERFORM procedure-1 «THROUGH procedure-2» «WITH» TEST AFTER UNTIL condition{{ref|COBOL THRU|[c]}};PERFORM procedure-1 «THROUGH procedure-2» VARYING i FROM first BY increment UNTIL i > last{{ref|COBOL GREATER THAN|[d]}};rowspan=2 {{n/a}};
PERFORM ««WITH» TEST BEFORE» UNTIL condition <dl><dd> expression </dd></dl> END-PERFORM;PERFORM «WITH» TEST AFTER UNTIL condition <dl><dd> expression </dd></dl> END-PERFORM;PERFORM VARYING i FROM first BY increment UNTIL i > last <dl><dd> expression </dd></dl> END-PERFORM{{ref|COBOL GREATER THAN|[d]}};
