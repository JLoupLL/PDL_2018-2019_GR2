! calling a function;basic/void function;value-returning function;required main function;
Ada[1];foo «(parameters)»;procedure foo «(parameters)» is begin statements end foo;function foo «(parameters)» return type is begin statements end foo;{{n/a}};
ALGOL 68;foo«(parameters)»;;proc foo = «(parameters)» void: ( instructions );;proc foo = «(parameters)» rettype: ( instructions ...; retvalue );;{{n/a}};
APL;«parameters» foo parameters;foo?{ statements };foo?{ statements };{{n/a}};
C (C99);foo(«parameters»);void foo(«parameters») { instructions };type foo(«parameters») { instructions ... return value; };«global declarations» int main(«int argc, char *argv[]») { <dl><dd>'''instructions'''</dd></dl> };
Objective-C;
C++ (STL);
C#;static void Main(«string[] args») { instructions } or static int Main(«string[] args») { instructions };
Java;public static void main(String[] args) { instructions } or public static void main(String... args) { instructions };
D;int main(«char[][] args») { instructions} or int main(«string[] args») { instructions} or void main(«char[][] args») { instructions} or void main(«string[] args») { instructions};
JavaScript;function foo(«parameters») { instructions } or var foo = function («parameters») {instructions } or var foo = new Function («"parameter", ... ,"last parameter"» "instructions");;function foo(«parameters») { instructions ... return value; };{{n/a}};
Go;func foo(«parameters») { instructions };func foo(«parameters») type { instructions ... return value };func main() { instructions };
Swift;func foo(«parameters») { instructions };func foo(«parameters») -> type { instructions ... return value };{{n/a}};
Common Lisp;(foo «parameters»);(defun foo («parameters»)<dl><dd>instructions''')'''</dd></dl> or (setf (symbol-function 'symbol)<dl><dd>lambda''')'''</dd></dl>;(defun foo («parameters»)<dl><dd>...</dd><dd>value''')'''</dd></dl>;rowspan=3 {{n/a}};
Scheme;(define (foo parameters) instructions) or (define foo (lambda (parameters) instructions));(define (foo parameters) instructions... return_value) or (define foo (lambda (parameters) instructions... return_value));
ISLISP;(defun foo («parameters»)<dl><dd>instructions''')'''</dd></dl>;(defun foo («parameters»)<dl><dd>...</dd><dd>value''')'''</dd></dl>;
Pascal;foo«(parameters)»;procedure foo«(parameters)»; «forward;»{{ref|forward declaration|[a]}} «label<dl><dd>label declarations»</dd></dl> «const<dl><dd>constant declarations»</dd></dl> «type<dl><dd>type declarations»</dd></dl> «var<dl><dd>variable declarations»</dd></dl> «local function declarations» begin<dl><dd>instructions</dd></dl>end;;function foo«(parameters)»: type; «forward;»{{ref|forward declaration|[a]}} «label<dl><dd>label declarations»</dd></dl> «const<dl><dd>constant declarations»</dd></dl> «type<dl><dd>type declarations»</dd></dl> «var<dl><dd>variable declarations»</dd></dl> «local function declarations» begin<dl><dd> instructions'''; <br/> foo := '''value</dd></dl>end;;program name; «label<dl><dd>label declarations»</dd></dl> «const<dl><dd>constant declarations»</dd></dl> «type<dl><dd>type declarations»</dd></dl> «var<dl><dd>variable declarations»</dd></dl> «function declarations» begin<dl><dd>instructions</dd></dl> end.;
Visual Basic;Foo(«parameters»);Sub Foo(«parameters») <dl><dd> '''instructions''' </dd></dl> End Sub;Function Foo(«parameters») As type <dl><dd>instructions<br/> '''Foo = '''value</dd></dl>End Function;Sub Main()<dl><dd>instructions</dd></dl>End Sub;
Visual Basic .NET;Function Foo(«parameters») As type <dl><dd>instructions<br/>'''Return '''value</dd></dl>End Function;Sub Main(«ByVal CmdArgs() As String») <dl><dd>'''instructions'''</dd></dl> End Sub or Function Main(«ByVal CmdArgs() As String») As Integer <dl><dd>'''instructions'''</dd></dl>End Function;
Xojo;
Python;foo(«parameters»);def foo(«parameters»): {{keypress|Tab}} instructions;def foo(«parameters»): {{keypress|Tab}} instructions {{keypress|Tab}} return value;{{n/a}};
S-Lang;foo(«parameters» «;qualifiers»);define foo («parameters») { instructions };define foo («parameters») { instructions ... return value; };public define slsh_main () { instructions };
Fortran;foo («arguments») CALL sub_foo («arguments»){{ref|Fortran arguments|[c]}};SUBROUTINE sub_foo («arguments») <dl><dd> '''instructions''' </dd></dl> END SUBROUTINE{{ref|Fortran arguments|[c]}};type FUNCTION foo («arguments») <dl><dd> '''instructions''' <br/> ... <br/> foo '''= value''' </dd></dl> END FUNCTION{{ref|Fortran arguments|[c]}};PROGRAM main <dl><dd> '''instructions''' </dd></dl> END PROGRAM;
Forth;«parameters» FOO;: FOO « stack effect comment: ( before -- ) » <dl><dd> '''instructions''' </dd></dl> ;;: FOO « stack effect comment: ( before -- after ) » <dl><dd> '''instructions''' </dd></dl> ;;{{n/a}};
PHP;foo(«parameters»);function foo(«parameters») { instructions };function foo(«parameters») { instructions ... return value; };rowspan=4 {{n/a}};
Perl;foo(«parameters») or &foo«(parameters)»;sub foo { «my (parameters) = @_;» instructions };sub foo { «my (parameters) = @_;» instructions... «return» value; };
Perl 6;foo(«parameters») or &foo«(parameters)»;«multi »sub foo(parameters) { instructions };«our «type» »«multi »sub foo(parameters) { instructions... «return» value; };
Ruby;foo«(parameters)»;def foo«(parameters)» <dl><dd>instructions </dd></dl> end;def foo«(parameters)» <dl><dd>instructions <br/> «'''return'''» value </dd></dl> end;
Rust;foo(«paramaters»);fn foo(«paramaters») { instructions };fn foo(«paramaters») -> type { instructions };fn main() { instructions };
Scala;foo«(parameters)»;def foo«(parameters)»«: Unit =» { instructions };def foo«(parameters)»«: type» = { instructions ... «return» value };def main(args: Array[String]) { instructions };
Windows PowerShell;foo «parameters»;function foo { instructions }; or function foo { «param(parameters)» instructions };function foo «(parameters)» { instructions … return value }; or function foo { «param(parameters)» instructions … return value };rowspan=4 {{n/a}};
Bash shell;foo «parameters»;<poem><code>'''function foo {''' {{space|4}}instructions '''}''' </code>or<code> '''foo () {''' {{space|4}}instructions ''' }'''</code></poem>;<poem><code>'''function foo {''' {{space|4}}instructions {{space|4}}'''return''' «exit_code» '''}''' </code>or<code> '''foo () {''' {{space|4}}instructions {{space|4}}'''return''' «exit_code» ''' }'''</code></poem>;
parameters $n ($1, $2, $3, ...) $@ (all parameters) $# (the number of parameters) $0 (this function name);
OCaml;foo parameters;let «rec» foo parameters = instructions;let «rec» foo parameters = instructions... return_value;
F#;[<EntryPoint>] let main args =''' instructions</code>;
Standard ML;fun foo parameters = ( instructions );fun foo parameters = ( instructions... return_value );;
Haskell;foo parameters = do {{keypress|Tab}} instructions;foo parameters = return_value or foo parameters = do {{keypress|Tab}} instructions {{keypress|Tab}} return value;«main :: IO ()» main = do instructions;
Eiffel;foo («parameters»);foo («parameters») <dl><dd>'''require''' <dl><dd>preconditions</dd></dl> do <dl><dd>instructions</dd></dl> ensure <dl><dd>postconditions</dd></dl> end</dd></dl>;foo («parameters»): type <dl><dd>'''require''' <dl><dd>preconditions</dd></dl> do <dl><dd>instructions</dd><dd>'''Result''' := value</dd></dl> ensure <dl><dd>postconditions</dd></dl> end</dd></dl>;{{ref|root class and feature|[b]}};
CoffeeScript;foo();foo = ->;foo = -> value;rowspan=2 {{n/a}};
foo parameters;foo = () ->;foo = ( parameters ) -> value;
COBOL;CALL "foo" «USING parameters» <dl><dd> «exception-handling» </dd></dl> «END-CALL»{{ref|COBOL calling programs|[d]}};«IDENTIFICATION DIVISION.» PROGRAM-ID. foo. «other divisions...» PROCEDURE DIVISION «USING parameters». <dl><dd> instructions'''.'''</dd></dl>;«IDENTIFICATION DIVISION.» PROGRAM-ID/FUNCTION-ID. foo. «other divisions...» DATA DIVISION. «other sections...» LINKAGE SECTION. «parameter definitions...» variable-to-return definition «other sections...» PROCEDURE DIVISION «USING parameters» RETURNING variable-to-return. <dl><dd> instructions'''.'''</dd></dl>;rowspan=2 {{n/a}};
«FUNCTION» foo«(«parameters»)»;{{n/a}};
